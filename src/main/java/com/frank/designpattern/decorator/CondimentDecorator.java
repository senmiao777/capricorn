package com.frank.designpattern.decorator;

/**
 * @author frank
 * @version 1.0
 * @date 2019/3/17 0017 上午 10:59
 * 调料抽象类，所有装饰器类都实现该抽象类
 * 设计原则讲“多用组合少用继承”，这里为什么用继承？
 * 这里用继承是为了让装饰器和被装饰者（组件）有共同的类型，而不是为了继承组件的行为。
 * 行为由装饰者和其他的组合提供。
 *
 * <p>
 * 如果只有一个装饰器类，则不需要写个抽象类了，直接继承就行了
 * 装饰器优点：
 * 解耦，各个装饰器实现类之间没有任何耦合，装饰器和组件类也没有耦合关系，可任意添加删除。
 * 扩展性强，装饰器可实现对组件类的动态扩展。
 * 非常符合“对修改关闭，对扩展开放”的设计原则
 * <p>
 * 缺点：
 * 装饰类越多越复杂，排错困难
 * 会产生更多的对象，一种装饰器会产生一个对象，增加出错的可能性。这个可以通过工厂模式很好的避免，工厂把对象产生的细节屏蔽了。
 * 所以说，可以的话，要做的事在一个装饰器里做了就OK
 * <p>
 * 使用场景：
 * 就一句话，当需要动态扩展类的功能的时候
 * n. 调味品，佐料; 英 [ˈkɒndɪmənt]
 */
public abstract class CondimentDecorator implements Beverage {
}
